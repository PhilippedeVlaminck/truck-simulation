// ===================================================================================
// --- Global Variables & Constants ---
// ===================================================================================
const canvas = document.getElementById('simulationCanvas');
const ctx = canvas.getContext('2d');

let PARAMS = {}; 

const TICKS_PER_SECOND = 30;
const SECONDS_PER_MINUTE = 60;
const SECONDS_PER_HOUR = 3600;
const SECONDS_PER_DAY = 86400;
const MAX_SPEED_MULTIPLIER = 5000;

// --- Image assets for the "gamified" look ---
const truckSprite = new Image();
truckSprite.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAdNSURBVChTY/z//z8DsYARJgZGIAYxQoADAwMDC5z//58ZGBgYGHj/948Bw58/fY6BgeE/DAwM/3//MkJjZGRg4PXrXwZmaGhofGRkZPgPBuI/IDOw5M+ffwaG//8ZGH5ERUJC4AEmSG9vb/gPBB8MTEBFePj9+z8DP7+//wxt3LjZgYEA415DQ0PDMzY2BvLzMcbAX19/GfD8+f+BJ0+eMHyE4TlmYGDg8ebNGR49esLw7NkzU5GRkeEBAQGmnz9/Zvj8+SsoISVFRkZGRkYGCysvoK5e/v8HAVBPTU1x/Pv2jcHxxg0Gff8yILi7u+f4/etXBlZWVgYGbn79Z2D4+/cXQ09f3z8MDAwM/v//Z4CSWlJSYmhlZcVQUFYeoKqpyYAnT58Z2FlZWVBXN2BnYGBgYMTGhvr7+v4D8X/8+BVDT0/PIygoCBaA0N+/f2dgZGRg+PLly0DXM1ARHj5//sxw+/YtAz8/P8Pata0Z2NnZgSBAuR8YGFhERUTFx8rKwsDAwAAaukAgDOD7928GUlJSsLKycgKBAv7//2d49OiJ4eHDhwwsLCxAfv7/DAwM/DAwMPyHCTAwMHBycsLw/ft3Bn5+fgZc3d3dDAwMDP8ZGBgY2FlZWVBtYwM7AwPDfwwMDAysbGwsCgoKIj4+PiYmJgYGhv8MvHjxxPDu3XsGVlZWAH7A8P//P8PCwoLh7du3DIyMjAyMDAwMDAxsbGyM//Pnz/8M/Pz8/v//Y5j7+vqG27dvGRgYGBgY+P//n+Hdu/cMzM3NDAycrKwsbKysDCysLAxsbGwsLCwMDAwMDP8Z+PPnDwMXR0ZGRnx8fAwMDAxsbGyMjIBAIDAgICC4e/cuAzu7u4GBAf4fGPh/YOD/BwYG+v/BYODg/wcHBv//wcDAwMDAwMDAgB8Y+P+BgeH/DAwM/DAwMPyHCTAwMDD8ycjAwMDgH9wYGBgY/jH+58+fGd5//2agpaVlwJWbmxsDAwMDP8Pdu3cMvH79ysDKyspAEyZ4+vSZYd68GQY+Pj4GXPX19QwsLCwMXH38+JHB3bsPDCxMLez8/f0NvHjxxPDw4UNDQ0NDAwP9MwxsbGzsDAwMDKwMDAxsrKz//zPAwsrKyMDAwMDAwP+fn5+Bnz9/Znh09EgDQ0NDA0NjNze3A4MD8O7dO8P3798MTE1N/f//jyHAnz9/Znh4eMjA0NjMzMzA3t6e4enTJ0Ovrq4M7O3tDBysrAwsrAxsDGwMDP3//w/k5ORkYGBg4ODgYGBnZ2dHR0eHx8fHz/z8/AyMjIyMTEzMDEwszMysrGzNzMzs7GyM7GwM7BwcDAxMDMzcDAyMjGwcLJwtDAyMjAycLKycrKwsLGwMDIxsbAwMjAwsrGxsrGysLGzsDAzcbGzcbGzc3NwMDAycnJwcDAwsrGzMDAwMDAxsDAwMDAz//w8A//8PMPz7NwMDAwMDAwPDfxgYGBgYWBgYGBn////fM/wHyAEAfmZ0N+i8fDkAAAAASUVORK5CYII=';
const asphaltTexture = new Image();
asphaltTexture.src = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBAUEBAYFBQUGBgYHCQ4JCQgICRINDQoOFRIWFhUSFBQXGI8SRCY1FhdbKYoHPDcwOzE2KjIUADI2M0I/KCj/2wBDAQYHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAgACADASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAT/xAAZEAEAAwEBAAAAAAAAAAAAAAABAgMQUWH/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A3TBjDGGLgsc4d1yXFcbY4bDFkSxljD//Z';
let asphaltPattern;
asphaltTexture.onload = () => { asphaltPattern = ctx.createPattern(asphaltTexture, 'repeat'); };

const DISTRIBUTION_WEIGHTS = {
    wave: [0.01, 0.01, 0.01, 0.01, 0.02, 0.04, 0.06, 0.08, 0.09, 0.07, 0.06, 0.05, 0.05, 0.06, 0.07, 0.08, 0.09, 0.06, 0.04, 0.02, 0.01, 0.01, 0.01, 0.01],
    spike: [0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.02, 0.03, 0.04, 0.15, 0.25, 0.15, 0.10, 0.05, 0.03, 0.02, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01],
};

const PROCESS_FLOW = ['access_control_arrival', 'self_arrival_handling', 'arrival_handling', 'execution', 'self_departure_handling', 'departure_handling', 'access_control_departure'];
const serverPoints = {};
let truckIdCounter, simulationTime, trucks, animationFrameId, isRunning;
let completedTrucksData = [];

function randomFloat(min, max) { return Math.random() * (max - min) + min; }
function capitalizeWords(str) {
    return str.replace(/_/g, ' ').replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
}
function generateHourlySchedule(totalTrucks, type, openingHour, closingHour) {
    const schedule = new Array(24).fill(0);
    const operatingHours = closingHour - openingHour;
    if (operatingHours <= 0) { return schedule; }
    if (type === 'even') {
        const trucksPerHour = totalTrucks / operatingHours;
        for (let i = openingHour; i < closingHour; i++) schedule[i] = Math.round(trucksPerHour);
    } else {
        const weights = DISTRIBUTION_WEIGHTS[type];
        const relevantWeights = weights.slice(openingHour, closingHour);
        const sumOfRelevantWeights = relevantWeights.reduce((sum, w) => sum + w, 0);
        if (sumOfRelevantWeights === 0) return generateHourlySchedule(totalTrucks, 'even', openingHour, closingHour);
        const rescaledWeights = relevantWeights.map(w => w / sumOfRelevantWeights);
        for (let i = 0; i < operatingHours; i++) {
            const hourIndex = openingHour + i;
            schedule[hourIndex] = Math.round(totalTrucks * rescaledWeights[i]);
        }
    }
    const currentTotal = schedule.reduce((sum, val) => sum + val, 0);
    let difference = totalTrucks - currentTotal;
    let hour = openingHour;
    while(difference !== 0) {
        schedule[hour % closingHour] += Math.sign(difference);
        difference -= Math.sign(difference);
        hour++;
        if (hour >= closingHour) hour = openingHour;
    }
    return schedule;
}

function updateParamsFromUI() {
    PARAMS.SERVERS = {};
    PROCESS_FLOW.forEach(p => PARAMS.SERVERS[p] = parseInt(document.getElementById(`s-${p}`).value));
    
    PARAMS.SERVICE_TIMES_MINUTES = {};
    PROCESS_FLOW.forEach(p => {
        PARAMS.SERVICE_TIMES_MINUTES[p] = { min: parseFloat(document.getElementById(`st-min-${p}`).value), max: parseFloat(document.getElementById(`st-max-${p}`).value) };
    });
    
    const openingHour = parseInt(document.getElementById('opening-hour').value);
    const closingHour = parseInt(document.getElementById('closing-hour').value);
    const totalTrucks = parseInt(document.getElementById('total-trucks-day').value);
    const distType = document.getElementById('distribution-type').value;
    PARAMS.HOURLY_ARRIVALS = generateHourlySchedule(totalTrucks, distType, openingHour, closingHour);
    document.getElementById('schedule-display').textContent = PARAMS.HOURLY_ARRIVALS.join(', ');

    PARAMS.TRAVEL_TIMES_MINUTES = {
        from_access_control_arrival: parseFloat(document.getElementById('tt-from-access_control_arrival').value),
        from_main_arrival: parseFloat(document.getElementById('tt-from-main_arrival').value),
        from_execution: parseFloat(document.getElementById('tt-from-execution').value),
        from_departure_handling: parseFloat(document.getElementById('tt-from-departure_handling').value),
        from_self_departure_handling: parseFloat(document.getElementById('tt-from-self_departure_handling').value)
    };
    
    PARAMS.BRANCHING = {
        arrival_success_percent: parseInt(document.getElementById('branch-arrival-success').value),
        departure_success_percent: parseInt(document.getElementById('branch-departure-success').value)
    };
    
    PARAMS.OPENING_HOUR = openingHour;
    PARAMS.CLOSING_HOUR = closingHour;

    const speedPercent = parseInt(document.getElementById('speed-multiplier').value);
    PARAMS.SPEED_MULTIPLIER = Math.floor((speedPercent / 100) * MAX_SPEED_MULTIPLIER);
    if (PARAMS.SPEED_MULTIPLIER < 1) PARAMS.SPEED_MULTIPLIER = 1;
}

function resetState() {
    truckIdCounter = 1;
    simulationTime = 0;
    trucks = [];
    completedTrucksData = [];

    for (const key in serverPoints) {
        const point = serverPoints[key];
        point.queue = [];
        point.stats = { trucksProcessed: 0, maxQueueLength: 0, totalWaitTime: 0, totalServiceTime: 0, totalBusyTime: 0, maxWaitTime: 0 };
        point.servers.forEach(s => { s.busy = false; s.truckId = null; });
    }

    initializeResultsTable();
    updateResultsDisplay();
    draw();
}

function fullResetAndSetup() {
    updateParamsFromUI();
    
    const pointDefinitions = {
        access_control_arrival:   { name: 'access_control_arrival',   x: 150, y: 100, next: 'self_arrival_handling', travelTime: PARAMS.TRAVEL_TIMES_MINUTES.from_access_control_arrival },
        self_arrival_handling:    { name: 'self_arrival_handling',    x: 150, y: 280, branch: { success_percent: PARAMS.BRANCHING.arrival_success_percent, success_path: 'execution', failure_path: 'arrival_handling' }, travelTime: PARAMS.TRAVEL_TIMES_MINUTES.from_main_arrival },
        arrival_handling:         { name: 'arrival_handling',         x: 300, y: 280, next: 'execution', travelTime: PARAMS.TRAVEL_TIMES_MINUTES.from_main_arrival },
        execution:                { name: 'execution',                x: 500, y: 500, next: 'self_departure_handling', travelTime: PARAMS.TRAVEL_TIMES_MINUTES.from_execution },
        self_departure_handling:  { name: 'self_departure_handling',  x: 850, y: 280, branch: { success_percent: PARAMS.BRANCHING.departure_success_percent, success_path: 'access_control_departure', failure_path: 'departure_handling' }, travelTime: PARAMS.TRAVEL_TIMES_MINUTES.from_self_departure_handling },
        departure_handling:       { name: 'departure_handling',       x: 700, y: 280, next: 'access_control_departure', travelTime: PARAMS.TRAVEL_TIMES_MINUTES.from_departure_handling },
        access_control_departure: { name: 'access_control_departure', x: 850, y: 100, next: 'exit', travelTime: 0.5 }
    };

    for (const key in pointDefinitions) {
        serverPoints[key] = { ...pointDefinitions[key], servers: [], queue: [] };
        const numServers = PARAMS.SERVERS[key] || 1;
        for (let i = 0; i < numServers; i++) serverPoints[key].servers.push({ busy: false, truckId: null, finishTime: 0 });
    }

    resetState();
}

class Truck {
    constructor() {
        this.id = truckIdCounter++; this.x = -40; this.y = 100; this.status = 'arriving';
        this.destination = serverPoints.access_control_arrival;
        this.targetX = serverPoints.access_control_arrival.x; this.targetY = serverPoints.access_control_arrival.y;
        this.rotation = 0;
        const travelSeconds = Math.abs(this.destination.x - this.x) / 50;
        this.finishTime = simulationTime + travelSeconds * TICKS_PER_SECOND;
        this.queueEnterTime = 0; this.creationTime = simulationTime; this.totalServiceTime = 0;
    }
    move() { const dx = this.targetX - this.x; const dy = this.targetY - this.y; this.rotation = Math.atan2(dy, dx); const speed = 3 * (PARAMS.SPEED_MULTIPLIER / 100) + 1; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < speed) { this.x = this.targetX; this.y = this.targetY; } else { this.x += (dx / distance) * speed; this.y += (dy / distance) * speed; } }
}

function update() { 
    simulationTime++;
    const currentHour = Math.floor((simulationTime / TICKS_PER_SECOND) / SECONDS_PER_HOUR) % 24;
    const isOpen = (currentHour >= PARAMS.OPENING_HOUR && currentHour < PARAMS.CLOSING_HOUR);
    if (isOpen) {
        const arrivalsThisHour = PARAMS.HOURLY_ARRIVALS[currentHour];
        const arrivalProbabilityPerTick = arrivalsThisHour / (SECONDS_PER_HOUR * TICKS_PER_SECOND);
        if (Math.random() < arrivalProbabilityPerTick) trucks.push(new Truck());
    }
    trucks.forEach(truck => {
        if (['arriving', 'traveling', 'exiting'].includes(truck.status)) truck.move();
        if ((truck.status === 'arriving' || truck.status === 'traveling') && simulationTime >= truck.finishTime) {
            if (truck.x === truck.targetX && truck.y === truck.y) {
                truck.status = 'queuing'; const dest = truck.destination;
                dest.queue.push(truck);
                truck.queueEnterTime = simulationTime;
                if (dest.queue.length > dest.stats.maxQueueLength) dest.stats.maxQueueLength = dest.queue.length;
            }
        }
    });
    PROCESS_FLOW.forEach(pointName => {
        const point = serverPoints[pointName]; if(!point) return;
        point.servers.forEach(server => {
            if(server.busy) point.stats.totalBusyTime++;
            if (server.busy && simulationTime >= server.finishTime) {
                const finishedTruck = trucks.find(t => t.id === server.truckId);
                if (finishedTruck) {
                    server.busy = false; server.truckId = null;
                    let nextPointName;
                    if (point.branch) {
                        const rand = Math.random() * 100;
                        if (rand < point.branch.success_percent) { nextPointName = point.branch.success_path; } else { nextPointName = point.branch.failure_path; }
                    } else { nextPointName = point.next; }
                    const nextPoint = serverPoints[nextPointName] || { name: 'exit' };
                    const travelDurationInTicks = point.travelTime * SECONDS_PER_MINUTE * TICKS_PER_SECOND;
                    if (nextPoint.name === 'exit') {
                        finishedTruck.status = 'exiting'; finishedTruck.targetX = canvas.width + 40; finishedTruck.targetY = finishedTruck.y;
                        finishedTruck.finishTime = simulationTime + (travelDurationInTicks || 30 * TICKS_PER_SECOND);
                        const turnaroundTime = simulationTime - finishedTruck.creationTime;
                        completedTrucksData.push({ turnaroundTime: turnaroundTime });
                    } else {
                        finishedTruck.status = 'traveling'; finishedTruck.destination = nextPoint;
                        finishedTruck.targetX = nextPoint.x; finishedTruck.targetY = nextPoint.y;
                        finishedTruck.finishTime = simulationTime + travelDurationInTicks;
                    }
                }
            }
        });
        if (point.queue.length > 0) {
            const freeServer = point.servers.find(s => !s.busy);
            if (freeServer) {
                const truck = point.queue.shift(); if (!truck) return;
                point.stats.trucksProcessed++;
                const waitTimeTicks = simulationTime - truck.queueEnterTime;
                point.stats.totalWaitTime += waitTimeTicks;
                if (waitTimeTicks > point.stats.maxWaitTime) { point.stats.maxWaitTime = waitTimeTicks; }
                freeServer.busy = true; freeServer.truckId = truck.id; truck.status = 'in_service';
                const sTimeParams = PARAMS.SERVICE_TIMES_MINUTES[pointName];
                const sDurationMins = randomFloat(sTimeParams.min, sTimeParams.max);
                const serviceDurationInTicks = sDurationMins * SECONDS_PER_MINUTE * TICKS_PER_SECOND;
                freeServer.finishTime = simulationTime + serviceDurationInTicks;
                point.stats.totalServiceTime += serviceDurationInTicks;
                truck.totalServiceTime += serviceDurationInTicks;
            }
        }
    });
    trucks = trucks.filter(truck => truck.x < canvas.width + 40);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (asphaltPattern) { ctx.fillStyle = asphaltPattern; ctx.fillRect(0, 0, canvas.width, canvas.height); } else { ctx.fillStyle = '#6c757d'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
    const p = serverPoints;
    ctx.strokeStyle = '#495057'; ctx.lineWidth = 60; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(-20, p.access_control_arrival.y); ctx.lineTo(p.access_control_arrival.x + 20, p.access_control_arrival.y); ctx.lineTo(p.self_arrival_handling.x, p.self_arrival_handling.y + 20); ctx.lineTo(p.execution.x - 20, p.execution.y); ctx.lineTo(p.self_departure_handling.x, p.self_departure_handling.y - 20); ctx.lineTo(p.access_control_departure.x - 20, p.access_control_departure.y); ctx.lineTo(canvas.width + 20, p.access_control_departure.y); ctx.stroke();
    ctx.lineWidth = 20; ctx.beginPath(); ctx.moveTo(p.self_arrival_handling.x, p.self_arrival_handling.y); ctx.lineTo(p.arrival_handling.x, p.arrival_handling.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.self_departure_handling.x, p.self_departure_handling.y); ctx.lineTo(p.departure_handling.x, p.departure_handling.y); ctx.stroke();
    ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.setLineDash([20, 25]);
    ctx.beginPath(); ctx.moveTo(-20, 100); ctx.lineTo(170, 100); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(830, 100); ctx.lineTo(canvas.width+20, 100); ctx.stroke();
    ctx.setLineDash([]);
    PROCESS_FLOW.forEach(pointName => {
        const point = serverPoints[pointName]; if (!point) return;
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)'; ctx.lineWidth = 2;
        const bayWidth = 40; for(let i=0; i < 10; i++) { ctx.strokeRect(point.x - (bayWidth/2), point.y + 25 + (i * 15), bayWidth, 10); }
        point.servers.forEach((server, i) => {
            const serverX = point.x - 12; const serverY = point.y - (i * 30) - 35;
            ctx.fillStyle = '#34495E'; ctx.fillRect(serverX, serverY, 24, 24);
            ctx.beginPath(); const lightX = serverX + 12; const lightY = serverY - 8;
            ctx.arc(lightX, lightY, 5, 0, 2 * Math.PI); ctx.fillStyle = server.busy ? '#F1C40F' : '#2ECC71'; ctx.fill();
            if (server.busy) { ctx.fillStyle = 'rgba(241, 196, 15, 0.3)'; ctx.arc(lightX, lightY, 8 + Math.sin(simulationTime / 8) * 2, 0, 2 * Math.PI); ctx.fill(); }
        });
        const displayName = capitalizeWords(point.name);
        ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.shadowColor = 'black'; ctx.shadowBlur = 5;
        ctx.fillText(displayName, point.x, point.y - (point.servers.length * 30) - 15);
        ctx.font = '12px Arial'; ctx.fillText(`(Q: ${point.queue.length})`, point.y > 400 ? point.x : point.x, point.y > 400 ? point.y + 70 : point.y + 85);
        ctx.shadowBlur = 0;
    });
    trucks.forEach(truck => {
        if (truck.status === 'queuing') {
            const point = truck.destination; if(point && point.queue){ const qIndex = point.queue.findIndex(t => t.id === truck.id); if (qIndex !== -1) { truck.x = point.x; truck.y = point.y + 30 + (qIndex * 15); truck.rotation = -Math.PI / 2; } }
        }
        ctx.save(); ctx.translate(truck.x, truck.y); ctx.rotate(truck.rotation);
        ctx.drawImage(truckSprite, -20, -10, 40, 20);
        ctx.restore();
    });
    ctx.textAlign = 'left'; ctx.font = 'bold 16px Arial'; ctx.fillStyle = 'white'; ctx.shadowColor = 'black'; ctx.shadowBlur = 7;
    const totalSeconds = Math.floor(simulationTime / TICKS_PER_SECOND); const day = Math.floor(totalSeconds / 86400); const hour = Math.floor((totalSeconds % 86400) / 3600); const minute = Math.floor((totalSeconds % 3600) / 60); const timeString = `Day ${day}, ${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
    ctx.fillText(timeString, 10, 25); if(PARAMS.HOURLY_ARRIVALS) { const arrivals = PARAMS.HOURLY_ARRIVALS[hour] || 0; ctx.fillText(`Expected Arrivals/hr: ${arrivals}`, 10, 45); }
    ctx.shadowBlur = 0;
}

function updateResultsDisplay() { /* ...unchanged... */
    PROCESS_FLOW.forEach(pName => {
        const point = serverPoints[pName]; if (!point) return;
        const avgWaitTicks = point.stats.trucksProcessed > 0 ? (point.stats.totalWaitTime / point.stats.trucksProcessed) : 0;
        const avgWaitMinutes = (avgWaitTicks / TICKS_PER_SECOND) / 60;
        const maxWaitMinutes = (point.stats.maxWaitTime / TICKS_PER_SECOND) / 60;
        const avgServiceTicks = point.stats.trucksProcessed > 0 ? (point.stats.totalServiceTime / point.stats.trucksProcessed) : 0;
        const avgServiceMinutes = (avgServiceTicks / TICKS_PER_SECOND) / 60;
        const totalPossibleTicks = point.servers.length * simulationTime;
        const utilization = totalPossibleTicks > 0 ? (point.stats.totalBusyTime / totalPossibleTicks) * 100 : 0;
        document.getElementById(`q-curr-${pName}`).textContent = point.queue.length;
        document.getElementById(`q-max-${pName}`).textContent = point.stats.maxQueueLength;
        document.getElementById(`wait-avg-${pName}`).textContent = avgWaitMinutes.toFixed(2);
        document.getElementById(`wait-max-${pName}`).textContent = maxWaitMinutes.toFixed(2);
        document.getElementById(`svc-avg-${pName}`).textContent = avgServiceMinutes.toFixed(2);
        document.getElementById(`util-${pName}`).textContent = utilization.toFixed(1);
        document.getElementById(`processed-${pName}`).textContent = point.stats.trucksProcessed;
    });
    if (completedTrucksData.length > 0) {
        const totalTurnaroundTicks = completedTrucksData.reduce((sum, data) => sum + data.turnaroundTime, 0);
        const avgTurnaroundTicks = totalTurnaroundTicks / completedTrucksData.length;
        const avgTurnaroundHours = (avgTurnaroundTicks / TICKS_PER_SECOND) / 3600;
        document.getElementById('avg-turnaround-time').textContent = avgTurnaroundHours.toFixed(2);
    } else { document.getElementById('avg-turnaround-time').textContent = "0.00"; }
}

function initializeResultsTable() {
    const tableBody = document.getElementById('results-body'); tableBody.innerHTML = '';
    PROCESS_FLOW.forEach(pName => {
        const displayName = capitalizeWords(pName);
        const row = document.createElement('tr');
        row.innerHTML = `<td>${displayName}</td><td id="q-curr-${pName}">0</td><td id="q-max-${pName}">0</td><td id="wait-avg-${pName}">0.00</td><td id="wait-max-${pName}">0.00</td><td id="svc-avg-${pName}">0.00</td><td id="util-${pName}">0.0</td><td id="processed-${pName}">0</td>`;
        tableBody.appendChild(row);
    });
}

function stopSimulation() {
    isRunning = false; 
    if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    startBtn.disabled = false;
    startBtn.textContent = 'Resume';
    stopBtn.disabled = false;
    stopBtn.textContent = 'Reset';
    stopBtn.classList.add('reset-mode');
}

function gameLoop() {
    if (!isRunning) return;
    const speed = PARAMS.SPEED_MULTIPLIER || 1;
    for (let i = 0; i < speed; i++) {
        update();
    }
    draw();
    if (simulationTime > 0 && simulationTime % 30 === 0) updateResultsDisplay();
    animationFrameId = requestAnimationFrame(gameLoop);
}

function startSimulation() {
    if (isRunning) return;
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    
    const startBtn = document.getElementById('start-btn');
    if (startBtn.textContent === 'Start') {
        fullResetAndSetup();
    }
    
    isRunning = true;
    const stopBtn = document.getElementById('stop-btn');
    startBtn.disabled = true;
    stopBtn.disabled = false;
    stopBtn.textContent = 'Stop';
    stopBtn.classList.remove('reset-mode');
    gameLoop();
}

document.addEventListener('DOMContentLoaded', () => {
    const setupOptionSelectors = () => {
        const speedControl = document.getElementById('speed-multiplier');
        for (let i = 5; i <= 100; i += 5) { const option = document.createElement('option'); option.value = i; option.textContent = `${i}%`; speedControl.appendChild(option); }
        speedControl.value = "100";
        const executionControl = document.getElementById('s-execution');
        for (let i = 1; i <= 25; i++) { const option = document.createElement('option'); option.value = i; option.textContent = i; if (i === 10) option.selected = true; executionControl.appendChild(option); }
    };

    setupOptionSelectors();
    
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    
    if (startBtn && stopBtn) {
        startBtn.addEventListener('click', startSimulation);
        stopBtn.addEventListener('click', () => {
            if (isRunning) {
                stopSimulation();
            } else {
                fullResetAndSetup();
                startBtn.textContent = 'Start';
                stopBtn.disabled = true;
                stopBtn.textContent = 'Stop';
                stopBtn.classList.remove('reset-mode');
            }
        });
        
        const arrivalControls = [document.getElementById('total-trucks-day'), document.getElementById('distribution-type'), document.getElementById('opening-hour'), document.getElementById('closing-hour')];
        arrivalControls.forEach(control => {
            control.addEventListener('change', () => {
                const totalTrucks = parseInt(document.getElementById('total-trucks-day').value);
                const distType = document.getElementById('distribution-type').value;
                const openingHour = parseInt(document.getElementById('opening-hour').value);
                const closingHour = parseInt(document.getElementById('closing-hour').value);
                PARAMS.HOURLY_ARRIVALS = generateHourlySchedule(totalTrucks, distType, openingHour, closingHour);
                document.getElementById('schedule-display').textContent = PARAMS.HOURLY_ARRIVALS.join(', ');
            });
        });
        
        fullResetAndSetup();
    } else {
        console.error("A control button was not found.");
    }
});